<!DOCTYPE html>
<html>
<head>
  <script src="jquery-1.2.3.pack.js"></script>
  <script src="processing-0.6.packed.js"></script>
  
  <meta charset="utf-8">
  
  <style type="text/css" media="screen">
    body { font-family: Helvetica, sans-serif; }
    a { text-decoration: none; }
    canvas { border: thin solid grey; }
    
    .legend {
        font-size: 11pt;
        
        display: none;
    }
    
    .legend UL {
        list-style-type: none;
        
        padding-left: 0;
        padding-right: 0;
        
        margin-left: 0;
        margin-right: 0;
    }
    
    .legend LI {
        display: inline;
        padding-left: 5px;
        padding-right: 10px;
        margin-right: 5px;
        border-right: thin dotted grey;
        
        border-left-style: solid;
        border-left-width: 20px;
    }
    
    .legend LI.header {
        border-left: none;
    }
  </style>
    
  <script type="text/javascript" charset="utf-8">
    // Data with muni shapes and other information
    // var gemdata = null;
    
    // Cache with centers for each muni
    // mapping of centerpoint -> name
    // var centers = {};
    
    // Data of election results
    var ep2009data = null;
    var gr2010data = null;
    
    var proc = null;
    
    var font = null;
    
    var colors = {};
    
    var leftValue = "";
    var rightValue = "";
    var leftMin = null;
    var leftMax = null;
    var rightMin = null;
    var rightMax = null;
    
    var backgroundColor = null;
    var defaultFill = null;
    
    
    var geosource = null;
    var datacatalog = null
    var geodrawers = {};
    
    function Legend(mapping) {
        this.mapping = mapping;
        
        // Origin
    }
    
    Legend.prototype.draw = function(proc) {
        // Draw legend starting from origin
    }
    
    
    function GeometrySource(geometry) {
        // Geometry is a key->label, value->geometrypath
        this.geometry = geometry;
        
        
        // Initialize min max values for geometry
        // TODO replace these with PVectors
        this.minX = 999999999999.9;
        this.maxX = 0;

        this.minY = 999999999999.9;
        this.maxY = 0;
        
        // A mapping of label -> PVector of centers for each geometry
        this.centers = {}
        
        this.calculateAllMinMax();
    }
    
    /**
     * Calculates min max values for the current geometry.
     */
    GeometrySource.prototype.calculateAllMinMax = function() {
        for (var index in this.geometry['features']) {
            if (index == 0) continue;

            var name = this.geometry['features'][index]['properties']['GM_NAAM'];

            var center = new proc.PVector(0, 0);

            var geom = this.geometry['features'][index]['geometry'];
            var points = null;
            if (geom['type'] == "MultiPolygon") {
                points = geom['coordinates'][0][0];
            } else {
                points = geom['coordinates'][0];
            }
            
            for (pIndex in points) {
                var point = points[pIndex];
                
                if (point[0] > this.maxX) this.maxX = point[0];
                if (point[0] < this.minX) this.minX = point[0];
                if (point[1] > this.maxY) this.maxY = point[1];
                if (point[1] < this.minY) this.minY = point[1];
                
                center.add(new proc.PVector(point[0], point[1]));
            }
            
            // Put RD values in centers
            this.centers[name] = new proc.PVector(center.x/points.length, center.y/points.length);
        }
    }
    
    
    function GeometryDrawer(geometrysource, datasource) {
        this.geometrysource = geometrysource;
        
        // Datasource returns a color value (or real value) for a given label
        this.datasource = datasource;
        
        this.PADDING = 20000;
    }
    
    GeometryDrawer.prototype.drawPolygon = function (proc, poly) {
        proc.beginShape();
        for (var index in poly[0]) {
            var point = poly[0][index];

            proc.vertex(proc.map(point[0], this.geometrysource.minX-this.PADDING, this.geometrysource.maxX+this.PADDING, 0, proc.height), 
                        proc.map(point[1], this.geometrysource.minY-this.PADDING, this.geometrysource.maxY+this.PADDING, proc.height, 0));
        }
        proc.endShape(proc.CLOSE);
    }
    
    GeometryDrawer.prototype.draw = function(proc) {
        for (var index in this.geometrysource.geometry['features']) {
            if (index == 0) continue; // Skip the first
            
            var feature = this.geometrysource.geometry['features'][index];
            
            var name = feature['properties']['GM_NAAM'];
            var coordinates = feature['geometry']['coordinates'];
            
            proc.fill(this.datasource.colourFor(name));
            // TODO implement real fill
            //proc.fill(defaultFill);
            
            if (feature['geometry']['type'] == "MultiPolygon") {
                for (var cIndex in coordinates) {
                    this.drawPolygon(proc, coordinates[cIndex]);
                }
            } else if (feature['geometry']['type'] == "Polygon") {
                this.drawPolygon(proc, coordinates);
            }
            
            proc.noFill();
        }
    }
    
    GeometryDrawer.prototype.setDataKey = function(key) {
        this.datasource.setDataKey(key);
    }
    
    
    function DataCatalog(geometrysource) {
        // The geometry also contains properties with interesting statistics
        this.geometrysource = geometrysource;
        
        // Names of the properties for each feature we are interested in
        this.featurepropnames = {
                            'AANT_INW': 'Aantal inwoners',
                            'BEV_DICHTH': 'Bevolkingsdichtheid',
                            "P_00_14_JR": 'Personen 0 tot 15 jaar',
                            "P_15_24_JR": 'Personen 15 tot 25 jaar',
                            "P_25_44_JR": 'Personen 25 tot 45 jaar',
                            "P_45_64_JR": 'Personen 45 tot 65 jaar',
                            "P_65_EO_JR": 'Personen 65 jaar en ouder',
                            'P_WEST_AL': 'Allochtonen — Westers totaal',
                            'P_N_W_AL': 'Allochtonen — Niet-westers totaal',
                            'P_TURKIJE': 'Allochtonen — Turkije',
                            'P_MAROKKO': 'Allochtonen — Marokko',
                            'P_SURINAM': 'Allochtonen — Suriname',
                            'P_ANT_ARU': 'Allochtonen — Ned. Antillen en Aruba',
                            'P_OVER_NW': 'Allochtonen — Overig niet-westers',
                            'P_EENP_HH': 'Eenpersoonshuishoudens',
                            'P_HH_Z_K': 'Huishoudens zonder kinderen',
                            'P_HH_M_K': 'Huishoudens met kinderen',
                            'GEM_HH_GR': 'Gemiddelde huishoudensgrootte',
                            'P_ONGEHUWD': 'Ongehuwd',
                            'P_GEHUWD': 'Gehuwd',
                            'P_GESCHEID': 'Gescheiden',
                            'AUTO_HH': 'Personenauto’s per huishouden',
                            'AUTO_LAND': 'Personenauto’s per oppervlakte',
                            'AGRA_BEDR': 'Aantal agrarische bedrijven'
                        };

        for(var propkey in this.featurepropnames) {
            appendToSelects(this.featurepropnames[propkey], propkey);
        }
        
        // Cache to store min max values for each property
        this.propMinMax = {}
        
        // Colors for the Dutch political parties
        this.partyColours = {
                    "CDA": proc.color(254, 119, 12),
                    "PvdA": proc.color(228, 6, 45),
                    "VVD": proc.color(13, 29, 111),
                    "D66": proc.color(254, 254, 0),
                    "GroenLinks": proc.color(149, 197, 64),
                    "SP": proc.color(128, 0, 128),
                    "PVV": proc.color(150, 75, 0),
                    "CU-SGP": proc.color(125),
                    "CU": proc.color(175),
                    "SGP": proc.color(100)
                }
        
        // Election data sources are mappings of label name to majority political party
        this.electionDataSources = {}
    }
    
    DataCatalog.prototype.addElectionDataSource = function(name, source) {
        this.electionDataSources[name] = source;
    }
    
    /**
     * Calculates the [min, max] for a property and stores it in the local cache.
     */
    DataCatalog.prototype.calculatePropMinMax = function(propname) {
        var min = 9999999999.9;
        var max = 0.0;
        
        for (var index in this.geometrysource.geometry['features']) {
            if (index == 0) continue;
            
            var value = this.geometrysource.geometry['features'][index]['properties'][propname];
            
            if (value < min) min = value;
            if (value > max) max = value;
        }
        
        this.propMinMax[propname] = {'min': min, 'max': max};
    }
    
    DataCatalog.prototype.colourFor = function(datakey, geolabel) {
        var returnColour = null;
        
        if (datakey in this.electionDataSources) {
            // Transform geolabels from old muninames to new ones
            // TODO only for elections or also for CBS stats?
            if (geolabel == "Bennebroek") geolabel = "Bloemendaal";
            else if (geolabel == "Hengelo (O.)") geolabel = "Bronckhorst";
            else if (geolabel == "Jacobswoude") geolabel= "Kaag en Braassem";
            else if (geolabel == "Alkemade") geolabel = "Kaag en Braassem";
            
            var party = this.electionDataSources[datakey][geolabel];
            returnColour = this.partyColours[party];
        } else if (datakey in this.featurepropnames) {
            // Check if property min and max have been calculated before
            if (!(datakey in this.propMinMax)) this.calculatePropMinMax(datakey);
            
            var features = this.geometrysource.geometry['features']
            
            for (var index in features) {
                if (features[index]['properties']['GM_NAAM']==geolabel) {
                    var val = features[index]['properties'][datakey];
                    
                    return proc.color(proc.map(val, this.propMinMax[datakey]['min'], this.propMinMax[datakey]['max'], 255, 0));
                }
            }
        }
        
        return returnColour;
    }
    
    /**
     * DataSource is set for a specific data value and maintains that setting for each 
     * geometry drawing object it is attached to.
     * 
     * The real data is contained in the DataCatalog.
     */
    function DataSource(datacatalog) {
        this.datacatalog = datacatalog;
        
        this.datakey = "";
    }
    
    DataSource.prototype.setDataKey = function(key) {
        this.datakey = key;
    }
    
    /** 
     * Return the color for the given name.
     */
    DataSource.prototype.colourFor = function(geolabel) {
        return this.datacatalog.colourFor(this.datakey, geolabel);
    }
    
    /** 
     * Provides the value mapping for every label in the source with datalabel
     */
    DataSource.prototype.returnLegend = function() {
    }
    

    function appendToSelects(name, value) {
        $('#dataselect-left').append($("<option></option>").attr("value", value).text(name));
        $('#dataselect-right').append($("<option></option>").attr("value", value).text(name));
    }
    
    $(document).ready(function() {        
        proc = Processing(document.getElementById('processing'));
        
        proc.setup = function() {
            proc.size(940, 450);
            
            font = proc.loadFont("Arial");
            proc.textFont(font); 
            proc.textSize(14);
            
            backgroundColor = proc.color(205, 218, 221);
            defaultFill = proc.color(255);
            
            proc.stroke(100);
            proc.strokeJoin(proc.ROUND);
            
            proc.frameRate(10);
        }
        
        proc.draw = function() {
            proc.background(backgroundColor);
            
            if (geodrawers['left']) {
                proc.pushMatrix();
                proc.translate(0, 0);
                geodrawers['left'].draw(proc);
                proc.popMatrix();
            }
            
            if (geodrawers['right']) {
                proc.pushMatrix();
                proc.translate(proc.width/2, 0);
                geodrawers['right'].draw(proc);
                proc.popMatrix();
            }
            
            /*
            // Find closest muni
            // TODO change this for a quadtree
            var lowestDistance = 9999999999.9;
            var muniWithLowest = "";
            for (var c in centers) {
                var mouseX = proc.mouseX;
                
                if (mouseX > proc.width/2) {
                    mouseX -= proc.width/2;
                }
                
                var dist = distance([mouseX, proc.mouseY], centers[c]);
                
                if (dist < lowestDistance) {
                    lowestDistance = dist;
                    muniWithLowest = c;
                }
            }
            
            proc.fill(0);
            proc.text(" " + muniWithLowest, 10, 20); 
            proc.noFill();
            */
        }
        
        $.getJSON('gem_2008_gn2.geo.json', function(data) {
            
            
            /*
            
            // Now that the ranges are known, remap the centers to screen coordinates (for the left half) for speed
            for (var c in centers) {
                var centerPoint = centers[c];
                centers[c] = [proc.map(centerPoint[0], minX, maxX, 20, 430), 
                                proc.map(centerPoint[1], minY, maxY, 430, 20)];
                
                // proc.println(c + ' ' + centers[c]);
            }
            */
            
            geosource = new GeometrySource(data);
            datacatalog = new DataCatalog(geosource);
            
            
            geodrawers['left'] = new GeometryDrawer(geosource, new DataSource(datacatalog));
            geodrawers['left'].setDataKey('P_HH_Z_K');
            
            geodrawers['right'] = new GeometryDrawer(geosource, new DataSource(datacatalog));
            geodrawers['right'].setDataKey('P_HH_M_K');
            
            
            $.getJSON('EP2009.json', function(data) {            
                datacatalog.addElectionDataSource('ep2009', data);
                appendToSelects('Europese Verkiezingen 2009', 'ep2009');
            });

            $.getJSON('GR2010.json', function(data) {
                datacatalog.addElectionDataSource('gr2010', data);
                appendToSelects('Gemeenteraadsverkiezingen 2010', 'gr2010');
            });
        });
        
        proc.init();
        
        function setHash() {
            window.location.hash = leftValue + ',' + rightValue;
        }
        
        function readHash() {
            // TODO implement
            
            /*
            if (window.location.hash.indexOf(',') != -1) {
                var parts = window.location.hash.substr(1).split(',');
                
                if (parts[0]) {
                    $('#dataselect-left').val(parts[0]);
                    $('#dataselect-left').change();
                }
                
                if (parts[1]) {
                    $('#dataselect-right').val(parts[1]);
                    $('#dataselect-right').change();
                }
            }
            */
        }
        
        $('#dataselect-left').change(function() {
            leftValue = $('#dataselect-left').val();
            
            geodrawers['left'].setDataKey(leftValue);
            
            setHash();
        });
        
        $('#dataselect-right').change(function() {
            rightValue = $('#dataselect-right').val();
            
            geodrawers['right'].setDataKey(rightValue);
            
            setHash();
        });
    });
  </script>
</head>

<body>

<select id="dataselect-left" style="float: left; margin-left: 150px;">
    <option value="">Kies linker gegevensbron…</option>
</select>

<select id="dataselect-right" style="float: left; margin-left: 250px;">
    <option value="">Kies rechter gegevensbron…</option>
</select>

<br style="clear: both;">

<canvas id="processing" width="940" height="450"></canvas>


<p style="margin-top: 3em;">Municipal boundaries and stats of 2006 from <a href="http://www.cbs.nl/nl-NL/menu/themas/dossiers/nederland-regionaal/publicaties/geografische-data/archief/2007/2006-wijk-en-buurtkaart.htm">Dutch Statistics Office</a>. Newer ones welcome (<a href="http://twitter.com/alper">contact</a>).</p>

<p>Election results for 2009 from <a href="http://nlverkiezingen.com">NL Verkiezingen</a>. Election results for 2010 via manual entry.</p>

<p><a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 License</a> by <a href="http://alper.nl">Alper Çu&#287;un</a></p>

<p id="log">
</p>
</body>
</html>
